/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.netbeans.lib.editor.codetemplates.storage.ui;

import java.awt.Color;
import java.awt.Component;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.DefaultListCellRenderer;
import javax.swing.DefaultListModel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.KeyStroke;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import org.netbeans.lib.editor.codetemplates.CodeTemplateHint;
import org.netbeans.lib.editor.codetemplates.CodeTemplateParameterImpl;
import org.netbeans.lib.editor.codetemplates.ParametrizedTextParser;
import org.netbeans.lib.editor.codetemplates.spi.CodeTemplateParameter;
import org.openide.util.Exceptions;
import org.openide.util.Utilities;

/**
 *
 * @author Arthur Sadykov
 */
class CodeTemplateParametersPanel extends JPanel {

    private static final int NUMBER_OF_RESERVED_PARAMETERS = 5;
    private final JTextComponent editor;

    CodeTemplateParametersPanel(JTextComponent editor, List<CodeTemplateHint> hints) {
        this.editor = editor;
        initComponents();
        setFocusable(false);
        setBackground(suggestionsList.getBackground());
        suggestionsScrollPane.setBackground(suggestionsList.getBackground());
        suggestionsList.setModel(createModel(hints));
        suggestionsList.setSelectedIndex(0);
        suggestionsList.setVisibleRowCount(hints.size() > Short.SIZE
                ? Short.SIZE
                : hints.size() + NUMBER_OF_RESERVED_PARAMETERS);
        suggestionsList.setCellRenderer(new Renderer(suggestionsList));
        suggestionsList.grabFocus();
        suggestionsList.addFocusListener(new FocusAdapter() {
            @Override
            public void focusLost(FocusEvent e) {
                PopupUtil.hidePopup();
            }
        });
    }

    private DefaultListModel<CodeTemplateParameterListItem> createModel(List<CodeTemplateHint> hints) {
        List<CodeTemplateParameterListItem> items = new ArrayList<>();
        hints.forEach(hint -> items.add(new CodeTemplateParameterListItem(hint.getName(), hint.getParameterText())));
        items.add(new CodeTemplateParameterListItem(CodeTemplateParameter.CURSOR_PARAMETER_NAME,
                "${" + CodeTemplateParameter.CURSOR_PARAMETER_NAME + "}")); //NOI18N
        items.add(new CodeTemplateParameterListItem(CodeTemplateParameter.SELECTION_PARAMETER_NAME,
                "${" + CodeTemplateParameter.SELECTION_PARAMETER_NAME + "}")); //NOI18N
        items.add(new CodeTemplateParameterListItem(CodeTemplateParameter.NO_FORMAT_PARAMETER_NAME,
                "${" + CodeTemplateParameter.NO_FORMAT_PARAMETER_NAME + "}")); //NOI18N
        items.add(new CodeTemplateParameterListItem(CodeTemplateParameter.NO_INDENT_PARAMETER_NAME,
                "${" + CodeTemplateParameter.NO_INDENT_PARAMETER_NAME + "}")); //NOI18N
        items.add(new CodeTemplateParameterListItem("${}", "${param}")); //NOI18N
        Collections.sort(items);
        DefaultListModel<CodeTemplateParameterListItem> model = new DefaultListModel<>();
        items.forEach(model::addElement);
        return model;
    }

    /**
     * This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        suggestionsScrollPane = new javax.swing.JScrollPane();
        suggestionsList = new javax.swing.JList<>();

        setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(64, 64, 64)));
        setLayout(new java.awt.BorderLayout());

        suggestionsScrollPane.setBorder(javax.swing.BorderFactory.createEmptyBorder(2, 4, 4, 4));

        suggestionsList.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                listMouseMoved(evt);
            }
        });
        suggestionsList.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                listMouseReleased(evt);
            }
        });
        suggestionsList.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                listKeyPressed(evt);
            }
        });
        suggestionsScrollPane.setViewportView(suggestionsList);

        add(suggestionsScrollPane, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    private void listMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_listMouseReleased
        invokeSelected();
    }//GEN-LAST:event_listMouseReleased

    private void invokeSelected() {
        PopupUtil.hidePopup();
        if (Utilities.isMac()) {
            // see issue #115106
            editor.requestFocus();
        }
        CodeTemplateParameterListItem listItem = suggestionsList.getSelectedValue();
        try {
            int caretPosition = editor.getCaretPosition();
            String parameterText;
            if (listItem.getName().equals(CodeTemplateParameter.CURSOR_PARAMETER_NAME)
                    || listItem.getName().equals(CodeTemplateParameter.SELECTION_PARAMETER_NAME)
                    || listItem.getName().equals(CodeTemplateParameter.NO_FORMAT_PARAMETER_NAME)
                    || listItem.getName().equals(CodeTemplateParameter.NO_INDENT_PARAMETER_NAME)) {
                parameterText = listItem.getParameterText();
            } else {
                parameterText = suggestParameterName(listItem.getParameterText(), editor.getText());
            }
            editor.getDocument().insertString(caretPosition, parameterText, null);
            int quoteIndex = parameterText.indexOf('"');
            if (quoteIndex > 0) {
                editor.setCaretPosition(caretPosition + quoteIndex + 1);
            }
            editor.requestFocus();
        } catch (BadLocationException ex) {
            Exceptions.printStackTrace(ex);
        }
    }

    private String suggestParameterName(String parameterText, String parametrizedText) {
        ParametrizedTextParser parser = new ParametrizedTextParser(null, parametrizedText);
        parser.parse();
        List<Integer> parameterSuffixes = new ArrayList<>();
        Map<Integer, Object> parametrizedTextFragmentsByOrdinal = parser.getParametrizedFragmentsByOrdinals();
        int numberOfFragments = parametrizedTextFragmentsByOrdinal.size();
        for (int i = 1; i < numberOfFragments; i += 2) {
            CodeTemplateParameterImpl parameter =
                    (CodeTemplateParameterImpl) parametrizedTextFragmentsByOrdinal.get(i);
            Matcher matcher = Pattern.compile("^param(\\d+)?$").matcher(parameter.getName()); //NOI18N
            if (matcher.matches()) {
                if (matcher.group(1) != null && !matcher.group(1).isEmpty()) {
                    parameterSuffixes.add(Integer.parseInt(matcher.group(1)));
                } else {
                    parameterSuffixes.add(0);
                }
            }
        }
        if (parameterSuffixes.isEmpty()) {
            return parameterText;
        }
        for (int i = 1; i < Integer.MAX_VALUE; i++) {
            if (!parameterSuffixes.contains(i)) {
                return "${param" + i + parameterText.substring(7); //NOI18N
            }
        }
        return parameterText;
    }


    private void listMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_listMouseMoved
        int idx = suggestionsList.locationToIndex(evt.getPoint());
        if (idx != suggestionsList.getSelectedIndex()) {
            suggestionsList.setSelectedIndex(idx);
        }
    }//GEN-LAST:event_listMouseMoved

    private void listKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_listKeyPressed
        KeyStroke keyStroke = KeyStroke.getKeyStrokeForEvent(evt);
        switch (keyStroke.getKeyCode()) {
            case KeyEvent.VK_ENTER:
            case KeyEvent.VK_SPACE:
                invokeSelected();
                break;
            case KeyEvent.VK_DOWN: {
                int size = suggestionsList.getModel().getSize();
                if (size > 0) {
                    int idx = (suggestionsList.getSelectedIndex() + 1) % size;
                    if (idx == size) {
                        idx = 0;
                    }
                    suggestionsList.setSelectedIndex(idx);
                    suggestionsList.ensureIndexIsVisible(idx);
                    evt.consume();
                }
                break;
            }
            case KeyEvent.VK_UP: {
                int size = suggestionsList.getModel().getSize();
                if (size > 0) {
                    int idx = (suggestionsList.getSelectedIndex() - 1 + size) % size;
                    suggestionsList.setSelectedIndex(idx);
                    suggestionsList.ensureIndexIsVisible(idx);
                    evt.consume();
                }
                break;
            }
            default:
                break;
        }
    }//GEN-LAST:event_listKeyPressed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JList<CodeTemplateParameterListItem> suggestionsList;
    private javax.swing.JScrollPane suggestionsScrollPane;
    // End of variables declaration//GEN-END:variables

    private static class Renderer extends DefaultListCellRenderer {

        private static final int DARKER_COLOR_COMPONENT = 5;
        private final Color foregroundColor;
        private final Color backgroundColor;
        private final Color backgroundColorDarker;
        private final Color backgroundSelectionColor;
        private final Color foregroundSelectionColor;

        private Renderer(JList<CodeTemplateParameterListItem> listItems) {
            setFont(listItems.getFont());
            foregroundColor = listItems.getForeground();
            backgroundColor = listItems.getBackground();
            backgroundColorDarker = new Color(Math.abs(backgroundColor.getRed() - DARKER_COLOR_COMPONENT),
                    Math.abs(backgroundColor.getGreen() - DARKER_COLOR_COMPONENT),
                    Math.abs(backgroundColor.getBlue() - DARKER_COLOR_COMPONENT));
            backgroundSelectionColor = listItems.getSelectionBackground();
            foregroundSelectionColor = listItems.getSelectionForeground();
        }

        @Override
        public Component getListCellRendererComponent(JList<?> items, Object value, int index, boolean isSelected,
                boolean hasFocus) {
            if (isSelected) {
                setForeground(foregroundSelectionColor);
                setBackground(backgroundSelectionColor);
            } else {
                setForeground(foregroundColor);
                setBackground(index % 2 == 0 ? backgroundColor : backgroundColorDarker);
            }
            if (value != null) {
                setText(((CodeTemplateParameterListItem) value).getName());
            }
            return this;
        }
    }

    private class CodeTemplateParameterListItem implements Comparable<CodeTemplateParameterListItem> {

        private final String name;
        private final String parameterText;

        private CodeTemplateParameterListItem(String name, String parameterText) {
            this.name = name;
            this.parameterText = parameterText;
        }

        private String getName() {
            return name;
        }

        private String getParameterText() {
            return parameterText;
        }

        @Override
        public int compareTo(CodeTemplateParameterListItem other) {
            return getName().compareTo(other.getName());
        }
    }
}
