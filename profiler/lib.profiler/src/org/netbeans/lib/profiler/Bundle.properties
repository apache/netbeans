# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

OpenIDE-Module-Display-Category=Profiling
OpenIDE-Module-Name=Java Profiler (JFluid)
ProfilerClient_CannotOpenServerTempFileMsg=Cannot open temporary communication file created at the server side.\nName\: {0}
ProfilerClient_PerformingInstrumentationString=Performing instrumentation, please wait...
ProfilerClient_InvalidCodeRegionMsg=Invalid location was specified for code region instrumentation.\nInstrumentation cannot be performed.
ProfilerClient_ClassNotFoundMsg=Could not find class {0} on the class path.\nInstrumentation cannot be performed.
ProfilerClient_OutOfMemoryMsg=Too much data collected - the profiler ran out of memory.\nCollected profiling data has been deleted and profiling resumed.\nTo avoid this error in future, increase the -Xmx value\n in the etc/netbeans.conf file in NetBeans installation\nor lower the amount of details in profiling settings.
ProfilerClient_IncorrectAgentVersionMsg=Warning\: The profiler agent you are connecting to is a different version than this profiler.\nYou may encounter errors and unexpected behavior.
ProfilerClient_ErrorGettingCalibrationDataMsg=Error when retrieving saved calibration data for target JVM\:\n{0}
ProfilerClient_MustCalibrateFirstMsg=Since you did not run the Profiler on this machine or target JVM before,\ndeleted the saved calibration data, or this data is corrupt, profiling will STOP now.\n\nYou have to run the calibration command for your target JVM\nbefore running the Profiler with it again.\nThe obtained calibration data will be saved and re-used\non subsequent runs, so you will not see this message anymore.\n\nTo perform the calibration, use\n\"Tools | Options | Java | Profiler | General | Manage calibration data\".\n\n
# HTML-formatted
ProfilerClient_MustCalibrateFirstShortMsg=<html><b>Calibration data missing.</b><br><br>Profiling cannot be started on this JDK. Please perform<br>profiler calibration first and start profiling again.</html>
# HTML-formatted
ProfilerClient_InstrumentationLimitReachedMsg=<html><b>The limit of 64K instrumented methods has been reached.</b><br><br>The profiler cannot instrument more methods, some of your code<br>will not be profiled.<br><br>To avoid this problem, limit the number of profiled classes by<br>changing the profiling roots and/or instrumentation filter.</html>
ProfilerClient_CorruptedTargetCalibrationDataMsg=Problem with saved calibration data on target machine\:\n{0}
ProfilerClient_ConnectVmMsg=Connecting to the target VM...
ProfilerClient_TargetJvmErrorMsg=Target JVM terminated unexpectedly or does not respond.\nWhen tried to send a message to it, got an IOException\:\n{0}
ProfilerClient_UnsupportedJvmMsg=Since the application you are trying to profile runs on {0} VM not supported by the Profiler, profiling will STOP now.\n\nPlease use 1.5.0 VM (Update 4 and higher) or 1.6.0 VM starting from build 26.

TargetAppRunner_ClasspathSettingsIgnoredMsg=The value of '-classpath' specified through 'Profile/Edit Settings' menu will be ignored.\nYou should specify the class path through 'File/Set class path' menu.
TargetAppRunner_ErrorStartingJvmMsg=When starting target JVM, with command: {0}, caught an exception\: {1}
TargetAppRunner_CalibrationSummaryShortMsg=The calibration was successful.\nClick Show Details to see calibration results.\n\nWarning\: If your computer uses dynamic CPU frequency switching,\nplease disable it and rerun calibration as changing the CPU frequency\nduring profiling would produce inaccurate results.
TargetAppRunner_CalibrationSummaryDetailsMsg=Some of the obtained calibration data is as follows\:\n\n
TargetAppRunner_FailedEstablishConnMsg=Failed to establish socket connection with the target JVM.
TargetAppRunner_UnexpectedProblemStartingAppMsg=Unexpected problem when trying to start target application\:\n
TargetAppRunner_JvmTerminatedNotRespondString=Target VM terminated or does not respond
TargetAppRunner_InternalProblemString=Internal problem
TargetAppRunner_FailedStartAppCauseMsg=Failed to start the target application. Cause\:\n{0}
TargetAppRunner_CalibrationResultsMsg=Approximate time in one methodEntry()/methodExit() call pair\:\nWhen getting absolute timestamp only\: {0} microseconds\nWhen getting thread CPU timestamp only\: {1} microseconds\nWhen getting both timestamps\: {2} microseconds\n\nApproximate time in one methodEntry()/methodExit() call pair\nin sampled instrumentation mode\: {3} microseconds\n
TargetAppRunner_CalibrationErrorMsg=Data transfer error during instrumentation calibration
TargetAppRunner_InternalStatisticsOnlyMsg=This is internal statistics that should be used only to estimate the efficiency\nof CPU profiling implementation. It is not for end-user results measurements.\n\n
TargetAppRunner_InstrMethodsCountMsg=Instrumented/hotswapped total of {0} methods
TargetAppRunner_ClassLoadFirstInvCountMsg=Issued {0} class load events, {1} first method invocation events
TargetAppRunner_NonEmptyImgCountMsg=Issued {0} non-empty InstrumentMethodGroup responses
TargetAppRunner_EmptyImgCountMsg=Issued {0} empty InstrumentMethodGroup responses
TargetAppRunner_SingleImgCountMsg=Issued {0} single method InstrumentMethodGroup responses
TargetAppRunner_AvgMethodTimeMsg=Average time per method group hotswapping/instrumentation operation\: {0} ms.
TargetAppRunner_MinMethodTimeMsg=Minimum time per method group hotswapping/instrumentation operation\: {0} ms.
TargetAppRunner_MaxMethodTimeMsg=Maximum time per method group hotswapping/instrumentation operation\: {0} ms.
TargetAppRunner_TotalRunTimeMsg=Total run time\: {0} ms.
TargetAppRunner_InjInstrTimeMsg=Time spent in injected instrumentation code for displayed thread\: {0} ms ({1} %)
TargetAppRunner_TotalInstrHotSwapTimeMsg=Total time spent in instrumentation/hotswapping in server\: {0} ms ({1} %)
TargetAppRunner_ByteCodeCommTimeMsg=Time spent in bytecode analysis/rewriting and wire communication in client\: {0} ms ({1} %)
TargetAppRunner_ClientByteCodeTimeMsg=Time spent in bytecode analysis/rewriting in client\: {0} ms
TargetAppRunner_ClientDiskProcessTimeMsg=Time spent in disk I/O and results processing in client\: {0} ms ({1} %)
TargetAppRunner_ClientResultsProcessTimeMsg=Time spent in results processing in client\: {0} ms.
TargetAppRunner_PerformingCalibrationMsg=Performing calibration, please wait...
