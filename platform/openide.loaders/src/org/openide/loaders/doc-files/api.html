<!--

    Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.

-->

<html><head>
<title>Datasystems API</title>
<link rel="stylesheet" href="@TOP@/resource-files/prose.css" type="text/css">
</head><body>

<p class="overviewlink"><a href="@TOP@/index.html">Overview</a></p>

<h1>Javadoc</h1>

There are three packages in this API:

<ul>

<li>{@link org.openide.loaders org.openide.loaders}
handles the association of files together into groups and assigning
types to data.

<li>{@link org.openide.cookies org.openide.cookies }

provides a design pattern for attachable behaviors for data objects and nodes.

<li>{@link org.openide.util.datatransfer org.openide.util.datatransfer }

implements some extensions to the clipboard.

</ul>

<h1>Contents</h1>

<ul>

<li><a href="#loader-do">Loaders and Data Objects</a>
<ul>
<li><a href="#intro-loader">What is a loader used for?</a>
<li><a href="#multi">Multiple-file loaders</a>
<li><a href="#single">Single-file loaders</a>
<li><a href="#entry">Entries</a>
<li><a href="#do-get">Getting a data object</a>
<li><a href="#delegate">Node Delegates</a>
<li><a href="#write-loader">Writing a loader and data object</a>
<li><a href="#sys-loaders">System loaders</a>
</ul>

<li><a href="#cookie">Cookies</a>
<ul>
<li><a href="#intro-cookie">What is a cookie?</a>
<li><a href="#std-cookie">Standard cookies and supports</a>
<li><a href="#write-cookie">Writing a cookie</a>
<li><a href="#write-support">Writing a support for an existing cookie</a>
<li><a href="#use-support">Using an existing support</a>
</ul>

<li><a href="#clipboard">Extended Clipboard</a>
<ul>
<li><a href="#convertor">Convertors</a>
<li><a href="#clipboard-ev">Event notification</a>
<li><a href="#multi-transfer">Multi-transfers</a>
</ul>

<li><a href="#diagrams">UML diagrams</a>
<ul>
<li><a href="#diagram_data_objects">Data objects class diagram</a>
<li><a href="#diagram_data_loaders">Data loaders class diagram</a>
</ul>


</ul>

<h1>Datasystems API</h1>

<h2 id="loader-do">Loaders and Data Objects</h2>

<div class="nonnormative">

There are a few related object types used in NetBeans to handle
creation of structured, high-level data based on files found on a

{@link org.openide.filesystems.FileSystem filesystem}.

In summary, the system {@link org.openide.loaders.DataLoaderPool loader pool}
is responsible for scanning files in a directory on disk, weeding out
irrelevant files of no interest, and grouping the rest into
logical chunks, or just determining what type of data each represents.
It does this scanning by asking each registered
{@link org.openide.loaders.DataLoader data loader}
whether or not the given file(s) should be handled. The first loader
to recognize a file takes ownership of it, and creates a matching
{@link org.openide.loaders.DataObject data object}
to represent it to the rest of NetBeans.

<h3 id="intro-loader">What is a loader used for?</h3>

There are a few reasons why loaders are used in NetBeans, rather than
just accessing raw files (and perhaps typing them by extension or MIME
type):

<ul>

<li>Most importantly, it is possible to group a cluster of files
together. For example, the NetBeans Form Editor module recognizes a
special cluster pattern:

<pre>
myform.java
myform.form
myform.class
myform$1.class
myform$2.class
</pre>

All of these files are handled by NetBeans as a single data object
with a single set of actions applicable to it. In the Explorer, only
one master node is created for this data object (though it has some
substructure) - the user does not see these files as isolated.

<li>Irrelevant files, such as backup files, test output, etc. do not
clutter up the displayed Filesystems, since no loader accepts them - so
no node is created for them in the Explorer.

<li>A data object holds a number of behaviors that a bare file object
does not. For example, it can hold <a href="#cookie">cookies</a>
providing various behaviors; have an associated opened editor; can be
specified as a template; may provide special procedures to be run when
it is moved or renamed; etc.

<li>Special pseudo-files, such as

{@link org.openide.loaders.DataShadow DataShadow }s,

are interpreted using Datasystems, not Filesystems.

</ul>

</div>

<h3 id="multi">Multiple-file loaders</h3>

These typically subclass

{@link org.openide.loaders.MultiFileLoader MultiFileLoader }.

Like the loader used by the Form Editor, they are able to recognize
multiple files at once and create a data object from them. All data
objects have a

{@link org.openide.loaders.DataObject#getPrimaryFile() primary file }

which is representative of the data object;
e.g. <code>myform.java</code> in the previous example. As well, these
multi loaders may have any number of

{@link org.openide.loaders.DataObject#files() secondary files }.

<p>The basic mechanism a multi-file loader uses, is that the loader
pool will pass it file objects to recognize in an arbitrary order; the
loader may get a primary or secondary file first. Either way, it must
recognize that it belongs to a cluster; find the primary file if it
got a secondary one; and create a new

{@link org.openide.loaders.MultiDataObject MultiDataObject }

containing the supplied file as an

{@link org.openide.loaders.MultiDataObject.Entry entry}.

When other files in the cluster are passed to the loader, it must
create new entries in the <em>same</em> multi data object, to indicate
their association.

<h3 id="single">Single-file loaders</h3>

These typically subclass

{@link org.openide.loaders.UniFileLoader UniFileLoader }.

A single-file loader is of course simpler, and is likely to be more
commonly used (since the majority of file types make sense by
themselves). The default implementation makes it straightforward to
create a subclass recognizing only certain file extensions.

<p>This kind of loader may be used for, e.g., HTML files which ought
to be recognized as such and given a simple data object appropriate to
working with HTML (so that opening it by default launches a web
browser, and so on).

<p>Note that the standard <code>UniFileLoader</code> is actually a
special type of <code>MultiFileLoader</code> (only recognizing one
file), so that it actually creates a

{@link org.openide.loaders.MultiDataObject MultiDataObject }

when it recognizes its file. Normally you will use a
<code>UniFileLoader</code> for most purposes, so the behaviors in
<code>MultiDataObject</code> are generally available as defaults. If
you had some reason to avoid using this kind of data object, you could
of course subclass <code>DataLoader</code> and <code>DataObject</code>
directly.

<h3 id="entry">Entries</h3>

Entries represent a single file in a <code>MultiDataObject</code>, and
thus are commonly used in all loaders (even single-file
loaders). Normally

{@link org.openide.loaders.MultiDataObject.Entry MultiDataObject.Entry }

will not be specially subclassed; most module authors will use

{@link org.openide.loaders.FileEntry FileEntry }

(a regular entry) and sometimes

{@link org.openide.loaders.FileEntry.Numb FileEntry.Numb }

(a discardable file which should not be slavishly moved about just
because the primary file is).

<p>Entries primarily handle operations on the whole file, such as
copying or instantiation from template, and provide the ability to
insert special behavior hooks into such operations, if desired. For
example, a Java source entry might want to rename its package and
class name when it was moved. (The easiest way to create "smart"
templates such as this is to make the entry a

{@link org.openide.loaders.FileEntry.Format FileEntry.Format }.)

<h3 id="do-get">Getting a data object</h3>

Normally you do not need to explicitly retrieve a data object - the
loader pool will create them on demand, present them to the user in
the Explorer as nodes, and user actions will trigger use of the data
object. However, if you do need to retrieve the data object for a file
object you may do so using

{@link org.openide.loaders.DataObject#find(org.openide.filesystems.FileObject) DataObject.find(...) },

which will create a new data object for the file if it needs to,
otherwise will return the existing one. (Catch

{@link org.openide.loaders.DataObjectNotFoundException DataObjectNotFoundException }

in case the file is not recognizable to any loader.)

<h3 id="delegate">Node Delegates</h3>

Data objects have separate, but associated,

Â¶@link org.openide.nodes.Node Node}s

which represent them in the Explorer and present a meaningful
interface to the user. You may use

{@link org.openide.loaders.DataObject#getNodeDelegate() DataObject.getNodeDelegate() }

to retrieve the node delegate for a data object, if necessary.

<h3 id="write-loader">Writing a loader and data object</h3>

This section is the most important for most people: after a loader has
been correctly written and installed, the system takes care of
providing files for it to recognize; constructing nodes for the files;
etc.; and most further implementation of a module will be callbacks
run in response to some aspect of the objects created here.

<h4 id="register">Module installation</h4>
<p>First of all, you must be able to register your loader in the
module so that NetBeans knows about it. The preferred way since version
7.0 of <code>org.openide.loaders</code> module is to assign the loader
to appropriate MIME type. If the 
{@link org.openide.filesystems.FileObject FileObject}
of your interest returns for example <code>text/xml+acme</code> from its
{@link org.openide.filesystems.FileObject#getMIMEType() getMIMEType() }
method, then you shall register its 
{@link org.openide.loaders.DataLoader DataLoader } or other configured 
{@link org.openide.loaders.DataObject.Factory DataObject.Factory } into layer file
of your module:
<pre>
&lt;folder name="Loaders"&gt;
  &lt;folder name="text"&gt;
    &lt;folder name="xml+acme"&gt;
      &lt;folder name="Factories"&gt;
        &lt;file name="org-acme-pkg-AcmeLoader.instance"&gt;
          &lt;attr name="position" intvalue="100"/&gt;
        &lt;/file&gt;
      &lt;/folder&gt;
    &lt;/folder&gt;
  &lt;/folder&gt;
&lt;/folder&gt;
</pre>
Then the <code>AcmeLoader</code> will be consulted everytime the system needs
to recognize file with <code>text/xml+acme</code> MIME type. Please refer 
to <a href="@org-openide-filesystems@/org/openide/filesystems/doc-files/HOWTO-MIME.html">
separate specification</a>
document on information how to register a MIME type declaratively.
<p>
The recognition process for any file consults loaders registered in an 
old, deprecated style first, then it checks folder
<code>Loaders/mime/type/Factories</code> for all instances of 
{@link org.openide.loaders.DataObject.Factory DataObject.Factory } which also includes
instances of 
all {@link org.openide.loaders.DataLoader DataLoader}s. If no appropriate loader
is found, the scan continues among loaders registered as
<code>Loaders/content/unknown/Factories</code>. At the end the recognition
checks standard system loaders. In case of registration of multiple loaders in
one folder you can specify their order by using the 
<a href="@org-openide-modules@/org/openide/modules/doc-files/api.html#how-layer">
position attributes</a>. Pay attention to whether this loader is potentially in conflict
with other existing or probable loaders; if so, you should specify
that it take higher or lower precedence than these others. (This would
be necessary, e.g., if your loader recognized everything that another
loader did, and used that loader, but also added further special
behavior.)

<h4>Deciding what to subclass</h4>

Your first step in writing the loader is deciding what to
subclass. Though you could in principle subclass
<code>DataLoader</code> directly, in practice it is easier and better
to subclass either

{@link org.openide.loaders.MultiFileLoader MultiFileLoader }

or

{@link org.openide.loaders.UniFileLoader UniFileLoader },

according to whether your loader needs to cluster files, or just needs
to deal with a single primary file.

<h4>Handling file recognition</h4>

For a single-file loader, handling file recognition is quite straightforward from the point of view of the API: you just need to override

{@link org.openide.loaders.UniFileLoader#findPrimaryFile(org.openide.filesystems.FileObject) UniFileLoader.findPrimaryFile(...) }

to return its argument if this file is of the type that should be
handled by your loader, or <code>null</code> if it is not.

<p>In fact, providing that your loader is of the common sort that just
looks for a specific file extension, you do not even need to override
this method at all; simply create an appropriate

{@link org.openide.loaders.ExtensionList ExtensionList }

and call

{@link org.openide.loaders.UniFileLoader#setExtensions(org.openide.loaders.ExtensionList) UniFileLoader.setExtensions(...) }

in your loader's constructor.

<p>For a multi-file loader, the situation is slightly more complex,
but still NetBeans takes care of most of the work for you. You should
implement

{@link org.openide.loaders.MultiFileLoader#findPrimaryFile(org.openide.filesystems.FileObject) MultiFileLoader.findPrimaryFile(...) }

as follows:

<ul>

<li>If the passed-in file object is of the correct type for your
primary file, just return it.

<li>If the passed-in file object is of the correct type for a
secondary file in your loader, you should attempt to find the primary
file which it should be associated with, and return that. For this
purpose, you may find it useful to call

{@link org.openide.filesystems.FileUtil#findBrother(org.openide.filesystems.FileObject,java.lang.String) FileUtil.findBrother(...) },

or perform a similar lookup by hand.

<li>Otherwise (if the passed-in object could not be either a primary
or secondary file), just return <code>null</code>.

</ul>

You need not worry about which order the primary and secondary files
are recognized in, or whether some other loader may have gotten to a
file first - the implementation in NetBeans takes care of this for you.

<h4>Creating the data object</h4>

The most interesting part of the loader is that which actually creates
the data object from the underlying file object. You must implement

{@link org.openide.loaders.MultiFileLoader#createMultiObject(org.openide.filesystems.FileObject) MultiFileLoader.createMultiObject(...) }

in order to do this. The method will be passed the correct primary
file object for you to work with.

<p>To write the data object, subclass

{@link org.openide.loaders.MultiDataObject MultiDataObject }.

Your constructor will call the superclass constructor (so the loader
will pass in the desired primary object and a reference to
itself). You do <em>not</em> need to worry about whether or not to
throw

{@link org.openide.loaders.DataObjectExistsException DataObjectExistsException }

in the constructor; it will be thrown automatically by the superclass if necessary.

<p>After that, what to override in the data object is up to you. Other
than things mentioned below, you may find it useful to prevent the
data object from being renamed or otherwise tampered with, if doing so
would make it useless or corrupted in some way; just return
<code>false</code> from e.g.

{@link org.openide.loaders.MultiDataObject#isRenameAllowed() MultiDataObject.isRenameAllowed() }.

<p>Or, if e.g. moves are to be permitted but require special
treatment, you may override e.g.

{@link org.openide.loaders.MultiDataObject#handleMove(org.openide.loaders.DataFolder) MultiDataObject.handleMove(...) }.

<h4>Choosing entry types</h4>

For single-file loaders, the default implementation of

{@link org.openide.loaders.UniFileLoader#createPrimaryEntry(org.openide.loaders.MultiDataObject,org.openide.filesystems.FileObject) UniFileLoader.createPrimaryEntry(...) }

just produces a

{@link org.openide.loaders.FileEntry FileEntry },

which is most likely what you want.

<p>For multi-file loaders, you must explicitly select the entry types
by implementing

{@link org.openide.loaders.MultiFileLoader#createPrimaryEntry(org.openide.loaders.MultiDataObject,org.openide.filesystems.FileObject) MultiFileLoader.createPrimaryEntry(...) }

and

{@link org.openide.loaders.MultiFileLoader#createSecondaryEntry(org.openide.loaders.MultiDataObject,org.openide.filesystems.FileObject) MultiFileLoader.createSecondaryEntry(...) }.

<p>Typically, the primary entry will be a <code>FileEntry</code>, and
will behave normally. The secondary entry might also be a
<code>FileEntry</code>, if it makes sense to move the secondary
entries along with the primary (i.e., if they are valuable enough to
do so, and will not be corrupted); in many cases you will want to use
a

{@link org.openide.loaders.FileEntry.Numb FileEntry.Numb },

which will not be moved along with the primary file, and may just
be discarded (for example, this would be useful for compiled
<code>*.class</code> files, cached indices, etc.). For such dummy
files, you will generally also want to use

{@link org.openide.filesystems.FileObject#setImportant(boolean) FileObject.setImportant(...) }

to prevent the file from being considered by a version control
system, for example.

<p>It is possible to specify custom copy/move/etc. behavior for
individual files in your data object by subclassing

{@link org.openide.loaders.MultiDataObject.Entry MultiDataObject.Entry }

(or <code>FileEntry</code>)
and providing a non-obvious implementation. If you need custom
behavior for the whole data object at once, it is preferable to do so
by overriding methods on the data object, as mentioned above.

<p>{@link org.openide.loaders.FileEntry.Format FileEntry.Format }

is a convenient entry type to use if you wish to perform substitution of some type
of token when creating the file from template. Typically the method

{@link org.openide.loaders.FileEntry.Format#createFormat(org.openide.filesystems.FileObject,java.lang.String,java.lang.String) FileEntry.Format.createFormat(...) }

will be implemented to return an instance of

{@link org.openide.util.MapFormat MapFormat }

containing substitution keys and values according to the name and package of the file object;
constants used by the module; values of associated system options; the current time and
date or user name; etc. For example, the Java data loader uses this entry type with a customized
<code>MapFormat</code> permitting it to replace keys such as <code>__NAME__</code> with the
(new) name of the class, or <code>__USER__</code> with the current user name (as taken from a
system option, defaulted from the Java system property).

<h4>Loader state and bean info</h4>

Data loaders all implicitly extend

{@link org.openide.util.SharedClassObject SharedClassObject },

which means that there is only intended to be a single instance of the loader
per class, and all associated configuration and properties are stored in a shared
state pool. <code>SharedClassObject</code> manages this state implicitly; if you
wish to associate any properties with a data loader, you should:

<ol>

<li> Implement getter and setter methods to call

{@link org.openide.util.SharedClassObject#getProperty(java.lang.Object) SharedClassObject.getProperty(key) }

and

{@link org.openide.util.SharedClassObject#putProperty(java.lang.String,java.lang.Object,boolean) SharedClassObject.putProperty(key, value, true) }

(the latter will automatically fire property changes and synchronize for you).

<li> Override <code>readExternal</code> and <code>writeExternal</code> to read and write
your property values from the stream. Please always first call the super methods.

</ol>

<p>You should use the method

{@link org.openide.util.SharedClassObject#initialize() SharedClassObject.initialize() }

to set up the shared instance, including both your own properties, and standard ones such as

{@link org.openide.loaders.DataLoader#setDisplayName(java.lang.String) DataLoader.setDisplayName(String) },

{@link org.openide.loaders.DataLoader#setActions(org.openide.util.actions.SystemAction[]) DataLoader.setActions(SystemAction[]) },

and

{@link org.openide.loaders.UniFileLoader#setExtensions(org.openide.loaders.ExtensionList) UniFileLoader.setExtensions(ExtensionList) }.

<p>Finally, data loaders will be customized by the user as Beans (and persisted using
externalization). For this reason, they should have an associated bean info class
which should typically specify:

<ol>

<li> A list of additional bean infos to retrieve (introspect on the superclass).

<li> Display names and hints (and property editors, etc.) for all properties you define.

<li> An icon.

</ol>

<h4>Providing cookies and actions</h4>

The most common way in which a new data object type will present its
useful features to NetBeans is by adding cookies and actions specific
to it. Please see the <a href="#cookie">cookie subsection</a> of this
document for information on cookies, and the

<a href="@org-openide-actions@/org/openide/actions/doc-files/api.html">Actions API</a>

for details on how to write actions.

<p>One simple way to add cookie support to a data object is simply to
implement the cookie's interface on the data object itself; then it
will automatically support the cookie. But doing so for many cookies
may be a bad idea, as your data object class will become cluttered;
and there is no way to alter the set of cookies provided in this way.

<p>A better technique is to provide cookies explicitly from

{@link org.openide.loaders.DataObject#getCookie(java.lang.Class) DataObject.getCookie(...) }.

Assuming that you are subclassing <code>MultiDataObject</code>, you
need not override this method yourself, but rather should use

{@link org.openide.loaders.MultiDataObject#getCookieSet() MultiDataObject.getCookieSet() }

in the constructor and add the cookies you
want to provide by default. Then it is possible to extend this set
later, and to more easily examine its contents.

<p>You may attach some

{@link org.openide.util.actions.SystemAction actions}

to the nodes <a href="#create-delegate">associated</a> with your data
objects. The easiest way to do this is to call

{@link org.openide.loaders.DataLoader#setActions(org.openide.util.actions.SystemAction[]) DataLoader.setActions(...) }

in your loader's

{@link org.openide.util.SharedClassObject#initialize() SharedClassObject.initialize() }

method, which lets you provide a set of
actions appropriate to all data objects created by this
loader. Please see the <a
href="@org-openide-actions@/org/openide/actions/doc-files/api.html#attach">Actions API</a> for
an example displaying suggested standard actions to include, and
their positioning.

<p>Or, you may wish to selectively attach actions to certain data
objects' nodes and not others. If you need to do this, please override

{@link org.openide.loaders.DataNode#getActions(boolean) DataNode.getActions(boolean) }

when creating your node delegate; you probably want to call the super
method and append any additional actions this particular node should
have.

<p>The nodes ought also to have a default action, which will be
performed in response to a generic user-initiated event, such as a
double-click on the node; this should do something safe and obvious on
the node, such as opening it for editing, running it if executable,
etc. To do so, your node delegate should override

{@link org.openide.loaders.DataNode#getPreferredAction() DataNode.getPreferredAction() }.

If unspecified, NetBeans may still provide a generic default action,
such as displaying properties of the object.

<p>The default implementation is only specified in the case of
templates, so you may override this. However, if there is a chance
this data object might serve as a template, for UI consistency this
default action should be preserved; you may check

{@link org.openide.loaders.DataObject#isTemplate() DataObject.isTemplate() },

and if true, provide

{@link org.openide.actions.InstantiateAction InstantiateAction}

as the result.

<h4 id="create-delegate">Creating a node delegate</h4>

You must create a

{@link org.openide.nodes.Node Node }

to represent your data object in the Explorer hierarchy, so that the
user may interact with it visually. The method

{@link org.openide.loaders.DataObject#createNodeDelegate() DataObject.createNodeDelegate() }

controls what sort of node should be created. To control the icon, you
should use

{@link org.openide.nodes.AbstractNode#setIconBaseWithExtension(java.lang.String) AbstractNode.setIconBaseWithExtension(...) }

on the newly created <code>DataNode</code>, either in its constructor
(if subclassing) or in <code>DataObject.createNodeDelegate()</code>.

<p>You have considerable latitude in creating this node; e.g. the Form
Editor actually creates a full hierarchy for nodes representing forms,
including one subtree representing the Java class object (and its
various members), as well as a subtree representing the component
structure of the form (as displayed in the Component Inspector).

<p>For simple loaders, it is not typically necessary to create a
special node subclass for the delegate, as you may provide an icon,
cookies, and common actions without doing so.

<h3 id="sys-loaders">System loaders</h3>

NetBeans installs a few extra "hidden" loaders into the loader pool, as
are returned by

{@link org.openide.loaders.DataLoaderPool#allLoaders() DataLoaderPool.allLoaders() }.

Currently, these include among other things:

<ul>

<li>A folder loader, which only recognizes file folders and creates a

{@link org.openide.loaders.DataFolder DataFolder }

for them. This folder will have a few standard system actions
associated with its

{@link org.openide.loaders.DataFolder.FolderNode node},

can be sorted, etc.

<li>A shadow loader, which recognizes files with a magic extension,
and treats them similarly to symbolic links. The created data object
is a

{@link org.openide.loaders.DataShadow DataShadow },

and generally behaves just like the object it points to.

<li>Support for

{@link org.openide.loaders.XMLDataObject XML files}.

</ul>

<!-- XXX no longer true probably
These system loaders always come first in the loader pool, so normally
they take precedence over module-installed loaders. However, if it is
necessary to override their behavior, it is possible for a data loader
to

<a href="../DataLoader.html#markFile(org.openide.filesystems.FileObject)">mark</a>

a file (e.g. a file folder or shadow file) as having the given loader
as its preferred loader, so that this loader will be given a first
shot at recognizing it. This is done using a special

<a href="@org-openide-filesystems@/org/openide/filesystems/FileObject.html#getAttributes()">file attribute</a>.
-->

<!-- XXX race condition, bad workaround
<p>Overriding a system loader is not very useful if the file might
have already been recognized by a system loader, which could be the
case if it was scanned for a data object before the custom loader got
to it (and this is difficult to predict); so this would better be done
upon

<a href="@org-openide-filesystems@/org/openide/filesystems/FileObject.html#getChildren()">creation</a>

of the file object by the underlying filesystem (which would need to
cooperate with the loader in this regard).
-->


<h2 id="cookie">Cookies</h2>

<!-- XXX this ss should maybe be in Services/Lookup API -->

Cookies provide a way for both data objects and nodes to indicate to
NetBeans in a flexible fashion what types of (usually user-initiated)
operations they are capable of supporting, and even to dynamically add
and remove these capabilities.

<h3 id="intro-cookie">What is a cookie?</h3>

A <em>cookie</em> is a design pattern used to separate the
presentation of implementation of some interface from the actual
object that implementation ought to be associated with. As such, it is
a convenient way of removing the requirement that all interfaces
presented by the cookie holder (either a data object or

{@link org.openide.nodes.Node node })

be actually implemented by the primary Java class of the object. If
desired, the primary Java class can in fact be the cookie implementor,
though this is a special case - some holder objects just declare
themselves by default to hold all cookies their own class implements.

<p><em>Take care</em> not to confuse this NetBeans usage of the word
with a different meaning sometimes used in computer science, that of
an opaque callback object.

<p>Originally there used to be a marker interface
{@link org.openide.nodes.Node.Cookie Node.Cookie },
however it is no longer necessary to use it. Rather rely on
{@link org.openide.nodes.Node#getLookup() getLookup }
method which can deal with plain Java objects.

As such there are no requirements as to what makes a valid
cookie - typically it will provide a small set of abstract operations,
such as "opening", "compiling", "searching", etc.

<p>Uses of cookies on nodes are not much different from uses on data
objects; the initial cookie detection is done by

{@link org.openide.nodes.Node#getLookup() Node.getLookup().lookup(...) } ;

however the default data node provides

{@link org.openide.loaders.DataNode DataNode.getLookup(...) }

that looks inside 

{@link org.openide.loaders.MultiDataObject#getCookieSet() MultiDataObject.getCookieSet() }.

<h4 id="attach-retrieve">Attaching and retrieving cookies</h4>

<p>In short, there are a number of ways to attach cookies to either a
node or data object (and you may listen for changes in the set of
supported cookies, etc.). In all cases, the
{@link org.openide.util.Lookup#lookup(java.lang.Class) lookup(Class) }
method
is used by the system to
determine whether or not a given cookie is supported: thus, cookies
are identified by their <em>representation class</em>, i.e. the Java
class of the cookie interface. The system will expect to find a cookie
object assignable to that representation class, and this object will
have methods invoked on it to perform the proper action; it is the
responsibility of that cookie object to associate itself to whatever
node or data object is holding it.

<p>Using

{@link org.openide.nodes.CookieSet cookie sets },

it is possible to dynamically add and remove cookies from a
holder (possible
using {@link org.openide.util.lookup.AbstractLookup AbstractLookup}).
This is appropriate for cookie types whose applicability may
vary over time. For example, some objects may be compilable at certain
times, but if they have been compiled recently and are already
up-to-date, this support should be temporarily disabled. In the common
case that an action (say, in the system Build menu for Compile) is
sensitive to the cookie provided by the currently selected object (in
this case the compilation cookie), this menu item can be automatically
grayed out when necessary; and then reenabled when either the
selection changes, or the object changes state so as to make the
cookie appropriate once more, at which time the folder re-adds the
cookie to its cookie set and
{@link org.openide.util.LookupListener LookupListener }
may observer the
{@link org.openide.nodes.Node#fireCookieChange() fired changes}
to this effect.

<h4>Cookie Usage Scenarios</h4>

<p>There are various scenarios for ways in which you can use cookies,
which demonstrate their flexibility. In the examples that follow,
<code>C</code> means a cookie interface (or abstract class),
<code>O</code> means a cookie holder (such as <code>Node</code> or
<code>DataObject</code>), and <code>S</code> means a cookie support
(concrete implementation). For example, signatures might look like
this:</p>

<pre>
<span class="keyword">public</span> <span class="keyword">interface</span> C {
    <span class="type">void</span> foo();
}
<span class="keyword">public</span> <span class="keyword">class</span> S <span class="keyword">implements</span> C {
    <span class="keyword">private</span> <span class="type">String</span> param;
    <span class="keyword">public</span> S(<span class="type">String</span> param) {
        <span class="keyword">this</span>.param = param;
    }
    <span class="keyword">public</span> <span class="type">void</span> foo() {
        System.out.println(<span class="string">"foo: "</span> + param);
    }
}
<span class="keyword">public</span> <span class="keyword">class</span> O <span class="keyword">extends</span> <span class="type">DataObject</span> {<span class="comment">/* ... */</span>}
</pre>


<dl>

<dt>Basic usage</dt>

<dd><p>Using cookies in the common way is pretty easy.</p>

<pre>
<span class="keyword">public</span> <span class="keyword">class</span> O <span class="keyword">extends</span> <span class="type">DataObject</span> {
    <span class="keyword">public</span> O(<span class="type">FileObject</span> fo) {
        <span class="comment">// super...
</span>        getCookieSet().assign(C1.class, <span class="keyword">new</span> S1(fo));
        getCookieSet().assign(C2.class, <span class="keyword">new</span> S2(<span class="keyword">this</span>));
    }
}
<span class="keyword">public</span> <span class="keyword">class</span> S1 <span class="keyword">implements</span> C1 {<span class="comment">/* ... */</span>}
<span class="keyword">public</span> <span class="keyword">class</span> S2 <span class="keyword">implements</span> C2 {<span class="comment">/* ... */</span>}
<span class="comment">// ...
</span><span class="type">DataObject</span> o = DataObject.find(someFileObject);
<span class="comment">// o instanceof O, in fact
</span>C1 c1 = o.getLookup().lookup(C1.<span class="keyword">class</span>);
<span class="comment">// c1 instanceof S1
</span><span class="keyword">if</span> (c1 != <span class="constant">null</span>) {
    c1.foo();
}
</pre>

</dd>

<dt>Multiple inheritance</dt>

<dd><p>Since cookies do not require language-level multiple
inheritance, you can use subclassing naturally on supports.</p>

<pre>
<span class="keyword">public</span> <span class="keyword">class</span> S1 <span class="keyword">implements</span> C1 {
    <span class="keyword">private</span> <span class="type">String</span> param;
    <span class="keyword">public</span> S1(<span class="type">String</span> param) {
        <span class="keyword">this</span>.param = param;
    }
    <span class="keyword">public</span> <span class="type">void</span> foo1() {
        System.out.println(<span class="string">"foo: "</span> + transform(param));
    }
    <span class="comment">/** Subclasses may customize. */</span>
    <span class="keyword">protected</span> <span class="type">String</span> transform(<span class="type">String</span> in) {
        <span class="keyword">return</span> in;
    }
}
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> S2 <span class="keyword">implements</span> C2 {
    <span class="keyword">private</span> <span class="type">String</span> param;
    <span class="keyword">public</span> S2(<span class="type">String</span> param) {
        <span class="keyword">this</span>.param = param;
    }
    <span class="keyword">public</span> <span class="type">void</span> foo2() {
        <span class="keyword">if</span> (active()) {
            System.out.println(<span class="string">"foo: "</span> + param);
        }
    }
    <span class="comment">/** Subclasses must implement. */</span>
    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">boolean</span> active();
}
<span class="keyword">public</span> <span class="keyword">class</span> O {
    <span class="keyword">private</span> <span class="type">int</span> state;
    <span class="keyword">public</span> O(<span class="type">String</span> p) {
        state = INACTIVE; <span class="comment">// initially
</span>        getCookieSet().assign(C1.class, <span class="keyword">new</span> <span class="type">MyS1</span>(p));
        getCookieSet().assign(C2.class, <span class="keyword">new</span> <span class="type">MyS2</span>(p));
    }
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="type">MyS1</span> <span class="keyword">extends</span> S1 {
        <span class="keyword">public</span> <span class="type">MyS1</span>(<span class="type">String</span> p) {<span class="keyword">super</span>(p);}
        <span class="keyword">protected</span> <span class="type">String</span> transform(<span class="type">String</span> in) {
            <span class="keyword">return</span> in.toLowerCase();
        }
    }
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="type">MyS2</span> <span class="keyword">extends</span> S2 {
        <span class="keyword">public</span> <span class="type">MyS2</span>(<span class="type">String</span> p) {<span class="keyword">super</span>(p);}
        <span class="keyword">protected</span> <span class="type">boolean</span> active() {
            <span class="keyword">return</span> O.<span class="keyword">this</span>.state == ACTIVE;
        }
    }
}
<span class="comment">// ...
</span>O o = <span class="keyword">new</span> O(<span class="string">"Hello"</span>);
C1 c1 = o.getLookup().lookup(C1.<span class="keyword">class</span>);
<span class="keyword">if</span> (c1 != <span class="constant">null</span>) c1.foo1();
<span class="comment">// prints "foo: hello"
</span>C2 c2 = o.getLookup().lookup(C2.<span class="keyword">class</span>);
<span class="keyword">if</span> (c2 != <span class="constant">null</span>) c2.foo2();
<span class="comment">// does nothing: o is not yet active
</span></pre>

</dd>

<dt>Dynamically add or remove a cookie</dt>

<dd><p>Sometimes you want to change the capabilities of an object
after its creation.</p>

<pre>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="type">O</span> {
    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable-name">modified</span>;
    <span class="keyword">public</span> <span class="function-name">O</span>(<span class="type">String</span> <span class="variable-name">param</span>) {
        modified = <span class="constant">false</span>;
        <span class="comment">// ...
</span>    }
    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">void</span> <span class="function-name">markModified</span>() {
        <span class="keyword">if</span> (!modified) {
            <span class="comment">// Newly modified, make it possible to save.
</span>            <span class="comment">// Note this will automatically fire a cookie change.
</span>            getCookieSet().assign(SaveCookie.class, <span class="keyword">new</span> <span class="type">SaveCookie</span>() {
                <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">save</span>() {
                    doSave();
                }
            });
            modified = <span class="constant">true</span>;
        }
    }
    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">void</span> <span class="function-name">doSave</span>() {
        <span class="keyword">if</span> (modified) {
            <span class="comment">// actually save...then:
</span>            
            getCookieSet().assign(SaveCookie.class);
            modified = <span class="constant">false</span>;
        }
    }
}
</pre>

</dd>


</dl>


<h3 id="std-cookie">Standard cookies and supports</h3>

Most standard cookies you would want to use exist in the

{@link org.openide.cookies org.openide.cookies }

package. Many of these have standard supports as well, frequently in

{@link org.openide.loaders org.openide.loaders }.

Using the Javadoc, the surest way to find cookies and supports is to
look at

{@link org.openide.nodes.Node.Cookie Node.Cookie}

and browse the subinterfaces; for any cookie of interest, just look
for implementing classes, which are usually supports. (A few cookie
implementations are not of general utility, and so are not documented
as being supports.) The standard supports generally take a

{@link org.openide.loaders.MultiDataObject.Entry file entry}

in their constructor, as they are designed for use by loaders
attaching them to data objects.

<p>Sometimes a cookie support that is applicable to multiple cookies
may not implement any of them, leaving the choice of which to declare
implementation of, to a subclass. This is the case with the abstract

{@link org.openide.loaders.OpenSupport OpenSupport},

which actually may be used for any or all of

{@link org.openide.cookies.OpenCookie OpenCookie},

{@link org.openide.cookies.ViewCookie ViewCookie},

or

{@link org.openide.cookies.CloseCookie CloseCookie},

according to the needs of its subclass and holders.

{@link org.openide.text.EditorSupport EditorSupport},

for instance, uses only <code>OpenCookie</code> and
<code>CloseCookie</code>.

<h3 id="write-cookie">Writing a cookie</h3>

Writing a new cookie requires no special knowledge - just extend create
an interface and add its methods according to whatever you need done.

<p>Often, in conjunction with writing a cookie you may want to create
an action which is <a href="#attach-retrieve">sensitive</a> to that
cookie. Then this action may be installed globally in the system (for
example, in a menu bar, on a shortcut, etc.), and only activated when
the current selection provides the cookie.</p>

<div class="nonnormative">

<h3 id="write-support">Writing a support for an existing cookie</h3>

Writing a support also does not require anything non-apparent. It should
be a concrete class, its name conventionally ending in
<code>Support</code>, implementing the cookie interface. Normally it
should have one constructor, taking a

{@link org.openide.loaders.MultiDataObject.Entry MultiDataObject.Entry}

as principal argument, so as to encourage its use in the context of a
loader; the file entry of course gives easy access to the file object
it represents, as well as the data object via

{@link org.openide.loaders.MultiDataObject.Entry#getDataObject() MultiDataObject.Entry.getDataObject() }.

<p>If the support is designed to be usable from someone else's loader,
and it is not obvious for which data objects using the support is
possible, you may be well advised to include a public, static tester
method in the support class indicating whether it would function
correctly with a given file entry/data object. This way, an
independently written loader could easily add the cookie with your
support to any data object it had, without knowing the details of its
prerequisites.

</div>

<h3 id="use-support">Using an existing support</h3>

Using an existing support is generally straightforward - assuming your
data object is a subclass of <code>MultiDataObject</code>, you may
just add a new instance of the support using

{@link org.openide.loaders.MultiDataObject#setCookieSet(org.openide.nodes.CookieSet) MultiDataObject.setCookieSet(...) }

in the constructor, passing in the primary entry (most likely) from

{@link org.openide.loaders.MultiDataObject#getPrimaryEntry() MultiDataObject.getPrimaryEntry() }.



<h2 id="clipboard">Extended Clipboard</h2>

NetBeans implements an extended clipboard, which enhances the functions
provided in the

{@link java.awt.datatransfer java.awt.datatransfer }

package. This implementation is to be found in

{@link org.openide.util.datatransfer org.openide.util.datatransfer }.

<p>Enabling complex customizations on both sides of a cut/copy-paste
can be confusing; the

<a href="@org-openide-nodes@/org/openide/nodes/doc-files/api.html#edit">Nodes API</a>

contains a detailed description of these operations as they pertain to
nodes, which may be helpful.

<h3 id="convertor">Convertors</h3>

The extended clipboard,

{@link org.openide.util.datatransfer.ExClipboard ExClipboard },

provides the ability for a prebuilt transferable to support additional
data flavors that it was not originally designed for; then the
convertor supplies the implementation of these conversions.

<p>To write a convertor, just implement

{@link org.openide.util.datatransfer.ExClipboard.Convertor ExClipboard.Convertor}.

The Javadoc should provide sufficient information on its sole
method. Installing the convertor is easy; you can just add an instance
of it to

<a href="@org-openide-util-ui@/org/openide/util/doc-files/api.html#instance-folders">lookup</a>.

<h3 id="clipboard-ev">Event notification</h3>

The extended clipboard supports Java Event-based notification of
changes in the contents of the clipboard. Just register your listener
with

{@link org.openide.util.datatransfer.ExClipboard#addClipboardListener(org.openide.util.datatransfer.ClipboardListener) ExClipboard.addClipboardListener(...) }.

<h3 id="multi-transfer">Multi-transfers</h3>

{@link org.openide.util.datatransfer.ExTransferable.Multi ExTransferable.Multi}

is a special transferable type used to transfer multiple objects (not
necessarily of the same type) at once. It only supports one, virtual
data flavor,

{@link org.openide.util.datatransfer.ExTransferable#multiFlavor ExTransferable.multiFlavor }.

<p>The data associated with <code>multiFlavor</code> in the
<code>ExTransferable.Multi</code> will always be a special container
object,

{@link org.openide.util.datatransfer.MultiTransferObject MultiTransferObject }.

It is designed to permit access to its constituent real
<code>Transferable</code>s.</p>

<div class="nonnormative">

<h2 id="diagrams">UML Diagrams</h2>

<h3 id="diagram_data_objects">Data objects</h3>

<img src="data_objects.gif" alt="DataObject UML">

<h3 id="diagram_data_loaders">Data loaders</h3>

<img src="data_loaders.gif" alt="DataLoader UML">

</div>


<hr>@FOOTER@

</body>
</html>
