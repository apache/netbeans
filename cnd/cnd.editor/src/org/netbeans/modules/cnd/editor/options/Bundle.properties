# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

Tab_Name=Formatting Style
Tab_Name_Mnemonic=S
Filter_TabsAndIndents_name=Tabs And Indents
Filter_Alignment_name=Alignment
Filter_Braces_name=Braces
Filter_BlankLines_name=Blank Lines
Filter_Spaces_name=Spaces
Filter_All_name=Formatting Style

LBL_TabsAndIndents=Indents
HINT_TabsAndIndents=Indents
LBL_indentSize=Indent Size
#LBL_indent-shift-width=Indent Size
HINT_indentSize=Number of spaces per indent
#HINT_indent-shift-width=Number of spaces per indent
LBL_expandTabToSpaces=Expand Tabs to Spaces
#LBL_expand-tabs=Expand Tabs to Spaces
HINT_expandTabToSpaces=Expand Tabs to Spaces
#HINT_expand-tabs=Expand Tabs to Spaces
LBL_tabSize=Tab Size
#LBL_tab-size=Tab Size
HINT_tabSize=Tab Size
#HINT_tab-size=Tab Size
LBL_statementContinuationIndent=Statement Continuation Indent
HINT_statementContinuationIndent=Shift for second and subsequent lines in a multi-line statement
LBL_constructorListContinuationIndent=Constructor Continuation Initializer List Indent
HINT_constructorListContinuationIndent=Shift for second and subsequent lines in a constructor initializer list
LBL_indentPreprocessorDirectives=Preprocessor Directives Indent
HINT_indentPreprocessorDirectives=Preprocessor directives indent
LBL_indentVisibility=Indent Visibility
HINT_indentVisibility=Indent Visibility
LBL_sharpAtStartLine=# at Start Line
HINT_sharpAtStartLine=# at start line
LBL_indentNamespace=Indent Namespaces
HINT_indentNamespace=Indent Namespaces
LBL_indentCasesFromSwitch=Indent Case Statements In Switch
HINT_indentCasesFromSwitch=Indent case statements in switch
LBL_absoluteLabelIndent=Absolute Label Indentation
HINT_absoluteLabelIndent=Move label in first column or indent by enclosing statement
LBL_spaceKeepExtra=Keep Extra Spaces
HINT_spaceKeepExtra=If there are several spaces inside a line, keep them.

LBL_BracesPlacement=Braces Placement
HINT_BracesPlacement=Right braces placement
LBL_newLineBeforeBraceNamespace=Namespace Declaration
HINT_newLineBeforeBraceNamespace=Namespace declaration
LBL_newLineBeforeBraceClass=Class Declaration
HINT_newLineBeforeBraceClass=Class/struct/enum/union declaration
LBL_newLineBeforeBraceDeclaration=Function Declaration
HINT_newLineBeforeBraceDeclaration=Method/function declaration
LBL_ignoreEmptyFunctionBody=Ignore Empty Function Body
HINT_ignoreEmptyFunctionBody=Ignore empty function body
LBL_newLineBeforeBraceLambda=Lambda
HINT_newLineBeforeBraceLambda=Lambda
LBL_newLineBeforeBraceSwitch="switch" Statement
HINT_newLineBeforeBraceSwitch="switch" statement
LBL_newLineBeforeBrace=Other
HINT_newLineBeforeBrace=Other right braces in blocks, compound statements

LBL_MultilineAlignment=Multiline Alignment
HINT_MultilineAlignment=Multiline alignment
LBL_alignMultilineArrayInit=Array Initializer
HINT_alignMultilineArrayInit=Array initializer
LBL_alignMultilineCallArgs=Function Call Arguments
HINT_alignMultilineCallArgs=Method/function call arguments
LBL_alignMultilineMethodParams=Function Parameters
HINT_alignMultilineMethodParams=Method/function parameters
LBL_alignMultilineParen=Other Parenthesis
HINT_alignMultilineParen=Other parenthesis in expressions

LBL_alignMultilineFor="for" Statement
HINT_alignMultilineFor="for" statement
LBL_alignMultilineIfCondition="if" Condition
HINT_alignMultilineIfCondition="if" condition
LBL_alignMultilineWhileCondition="while" Condition
HINT_alignMultilineWhileCondition="while" condition

LBL_NewLine=New Line
HINT_NewLine=New line
LBL_newLineFunctionDefinitionName=Function Name
HINT_newLineFunctionDefinitionName=Move function definition name on the first column or keep user style
LBL_newLineCatch="catch"
HINT_newLineCatch="catch" on new line
LBL_newLineElse="else"
HINT_newLineElse="else" on new line
LBL_newLineWhile="while"
HINT_newLineWhile="while" on new line in the do-while statement

LBL_BeforeKeywords=Spaces Before Keywords
HINT_BeforeKeywords=Spaces before keywords 
LBL_spaceBeforeCatch="catch"
HINT_spaceBeforeCatch=Spaces before "catch"
LBL_spaceBeforeElse="else"
HINT_spaceBeforeElse=Spaces before "else"
LBL_spaceBeforeWhile="while"
HINT_spaceBeforeWhile=Spaces before "while" in the do-while statement

LBL_BeforeParentheses=Spaces Before Parentheses
HINT_BeforeParentheses=Spaces before parentheses
LBL_spaceBeforeMethodDeclParen=Function Declaration
HINT_spaceBeforeMethodDeclParen=Method/function declaration
LBL_spaceBeforeMethodCallParen=Function Call
HINT_spaceBeforeMethodCallParen=Method/function call
LBL_spaceBeforeCatchParen="catch"
HINT_spaceBeforeCatchParen="catch"
LBL_spaceBeforeForParen="for"
HINT_spaceBeforeForParen="for"
LBL_spaceBeforeIfParen="if"
HINT_spaceBeforeIfParen="if"
LBL_spaceBeforeSwitchParen="switch"
HINT_spaceBeforeSwitchParen="switch"
LBL_spaceBeforeWhileParen="while"
HINT_spaceBeforeWhileParen="while"
LBL_spaceBeforeKeywordParen=Other Keywords
HINT_spaceBeforeKeywordParen=Spaces before parentheses and after return, sizeof and other keywords

LBL_AroundOperators=Spaces Around Operators
HINT_AroundOperators=Spaces around operators
LBL_spaceAroundAssignOps=Assignment Operators
HINT_spaceAroundAssignOps=Assignment operators
LBL_spaceAroundBinaryOps=Binary Operators
HINT_spaceAroundBinaryOps=Binary operators
LBL_spaceAroundTernaryOps=Ternary Operators
HINT_spaceAroundTernaryOps=Ternary operators
LBL_spaceAroundUnaryOps=Unary Operators
HINT_spaceAroundUnaryOps=Space between unary operator and its operand

LBL_BeforeLeftBraces=Spaces Before Left Braces
HINT_BeforeLeftBraces=Spaces before left braces
LBL_spaceBeforeClassDeclLeftBrace=Class Declaration
HINT_spaceBeforeClassDeclLeftBrace=Class/struct/enum/union declaration
LBL_spaceBeforeMethodDeclLeftBrace=Function Declaration
HINT_spaceBeforeMethodDeclLeftBrace=Method/function declaration
LBL_spaceBeforeLambdaLeftBrace=Lambda
HINT_spaceBeforeLambdaLeftBrace=Lambda
LBL_spaceBeforeArrayInitLeftBrace=Array Initializer
HINT_spaceBeforeArrayInitLeftBrace=Array initializer
LBL_spaceBeforeCatchLeftBrace="catch"
HINT_spaceBeforeCatchLeftBrace="catch"
LBL_spaceBeforeDoLeftBrace="do"
HINT_spaceBeforeDoLeftBrace="do"
LBL_spaceBeforeElseLeftBrace="else"
HINT_spaceBeforeElseLeftBrace="else"
LBL_spaceBeforeForLeftBrace="for"
HINT_spaceBeforeForLeftBrace="for"
LBL_spaceBeforeIfLeftBrace="if"
HINT_spaceBeforeIfLeftBrace="if"
LBL_spaceBeforeSwitchLeftBrace="switch"
HINT_spaceBeforeSwitchLeftBrace="switch"
LBL_spaceBeforeTryLeftBrace="try"
HINT_spaceBeforeTryLeftBrace="try"
LBL_spaceBeforeWhileLeftBrace="while"
HINT_spaceBeforeWhileLeftBrace="while"

LBL_WithinParentheses=Spaces Within Parentheses
HINT_WithinParentheses=Spaces within parentheses
LBL_spaceWithinMethodDeclParens=Function Declaration
HINT_spaceWithinMethodDeclParens=Method/function declaration
LBL_spaceWithinMethodCallParens=Function Call
HINT_spaceWithinMethodCallParens=Method/function call
LBL_spaceWithinBraces=Braces
HINT_spaceWithinBraces=Braces
LBL_spaceWithinParens=Parentheses
HINT_spaceWithinParens=Parentheses
LBL_spaceWithinCatchParens="catch"
HINT_spaceWithinCatchParens="catch"
LBL_spaceWithinForParens="for"
HINT_spaceWithinForParens="for"
LBL_spaceWithinIfParens="if"
HINT_spaceWithinIfParens="if"
LBL_spaceWithinSwitchParens="switch"
HINT_spaceWithinSwitchParens="switch"
LBL_spaceWithinTypeCastParens=Type Cast
HINT_spaceWithinTypeCastParens=Type cast
LBL_spaceWithinWhileParens="while"
HINT_spaceWithinWhileParens="while"

LBL_Other_Spaces=Other Spaces
HINT_Other_Spaces=Other spaces
LBL_spaceBeforeComma=Before Comma
HINT_spaceBeforeComma=Before comma
LBL_spaceAfterComma=After Comma
HINT_spaceAfterComma=After comma
LBL_spaceBeforeSemi=Before Semicolon
HINT_spaceBeforeSemi=Before semicolon
LBL_spaceAfterSemi=After Semicolon
HINT_spaceAfterSemi=After semicolon
LBL_spaceBeforeColon=Before Colon
HINT_spaceBeforeColon=Before colon
LBL_spaceAfterColon=After Colon
HINT_spaceAfterColon=After colon
LBL_spaceAfterTypeCast=After Type Cast
HINT_spaceAfterTypeCast=After type cast
LBL_spaceAfterOperatorKeyword=After operator Keyword
HINT_spaceAfterOperatorKeyword=After operator keyword

LBL_BlankLines=Blank Lines
HINT_BlankLines=Blank lines
LBL_blankLinesBeforeClass=Before Class
HINT_blankLinesBeforeClass=Before class/struct/union/enum
#LBL_blankLinesAfterClass=After Class
#HINT_blankLinesAfterClass=After class/struct/union/enum
LBL_blankLinesAfterClassHeader=After Class Header
HINT_blankLinesAfterClassHeader=After class/struct/union/enum header
#LBL_blankLinesBeforeFields=Before Field
#HINT_blankLinesBeforeFields=Before field
#LBL_blankLinesAfterFields=After Field
#HINT_blankLinesAfterFields=After field
LBL_blankLinesBeforeMethods=Before Function
HINT_blankLinesBeforeMethods=Before method/function definition
#LBL_blankLinesAfterMethods=After Method
#HINT_blankLinesAfterMethods=After method/function

LBL_Other=Other
HINT_Other=Other
LBL_addLeadingStarInComment=Add Leading Star in Comment
HINT_addLeadingStarInComment=Add leading star in comment
LBL_useBlockComment=Toggle block comment
HINT_useBlockComment=Use block comment instead of line comment by Toggle Comment action
LBL_useInlineKeyword=Insert 'inline' keyword
HINT_useInlineKeyword=Use 'inline' keyword when generate getters and setters
LBL_Style_Name=&Style:
EditorPropertySheet.manageStyles.text=&Manage


Apache_Name=Apache
GNU_Name=GNU
Default_Name=NetBeans
Linux_Name=Linux
ANSI_Name=ANSI
OpenSolaris_Name=OpenSolaris
KandR_Name=K&R
MySQL_Name=MySQL
Whitesmiths_Name=Whitesmiths
clang-format_Name=Use clang-format

CopyOfStyle={0} (Copy)
Custom_Name=Custom
Duplicate_Style_Warning=Style {0} already exists

MANAGE_STYLES_DIALOG_TITLE=Manage Styles
ManageStylesPanel.newButton.text=&New
ManageStylesPanel.duplicateButton.text=&Duplicate
ManageStylesPanel.removeButton.text=&Remove

EDIT_DIALOG_TITLE_TXT=Style Name
EDIT_DIALOG_LABEL_TXT=&Name:

AN_Preview=Preview
AD_Preview=Preview
LBL_OverrideGlobalOptions=&Override Global Options
NewStyleName.idLabel.text=&ID:

NonNegativeValue=Negative value is not allowed

# Should not be translated
SAMPLE_AlignBraces_cpp=class ClassA : InterfaceA, InterfaceB, InterfaceC {\n\
public:\n\
int number = 1;\n\
private:\n\
String letters[] = new String[]{ "A", "B", "C", "D" };\n\
ClassA() {\n\
}\n\
public:\n\
int method(String text,\n\
int number, Object object) throw ExceptionA, ExceptionB {\n\
printf(nuber + text.length() < 20 ? "message1" : "message2",\n\
       25);\n\
if ( text == null ) {\n\
text = "a";\n\
}\n\
else if (text.length() == 0) {\n\
text = number == 2 ? "empty" : "nonempty";\n\
number = ((op3() + 2) * op4);\n\
}\n\
else {\n\
    number++;\n\
}\n\
for( int i = 1; i < 100; i++ ) {\n\
}\n\
while ( this->number < 2 && number != 3 ) {\n\
method( "Some text", 12,\n\
        new Object());\n\
}\n\
do {\n\
try {\n\
op1().op2.op3().op4();\n\
}\n\
catch ( Throwable t ) {\n\
log();\n\
}\n\
} while ( this->number < 2 && number != 3 );\n\
switch(number) {\n\
case 1:\n\
    return method("text", 22);\n\
case 2:\n\
    return 20;\n\
default:\n\
    return -1;\n\
}\n\
}\n\
enum Where {\n\
NORTH, EAST, SOUTH, WEST;\n\
};\n\
};\n\


# Should not be translated
SAMPLE_AlignBraces_c=struct StructA {\n\
int number;\n\
char* letters;\n\
};\n\
enum Where {\n\
NORTH, EAST, SOUTH, WEST;\n\
};\n\
int method(char* text,\n\
int number, Object object) {\n\
printf(number + text.length() < 20 ? "message1" : "message2",\n\
25);\n\
if ( text == NULL ) {\n\
text = "a";\n\
}\n\
else if (strlen(text) == 0) {\n\
text = number == 2 ? "empty" : "nonempty";\n\
number = ((op3() + 2) * op4);\n\
}\n\
else {\n\
    number++;\n\
}\n\
for( int i = 1; i < 100; i++ ) {\n\
}\n\
while ( number < 2 && number != 3 ) {\n\
method( "Some text", 12,\n\
new Object());\n\
}\n\
do {\n\
op1().op2.op3().op4();\n\
} while ( number < 2 && number != 3 );\n\
switch(number) {\n\
case 1:\n\
    return method("text", 22);\n\
case 2:\n\
    return 20;\n\
default:\n\
    return -1;\n\
}\n\
}\n\


# Should not be translated
SAMPLE_Spaces_cpp=class ClassA {\n\
public:\n\
int            number;\n\
private:\n\
String         text;\n\
static float[] floats;\n\
protected:\n\
double[]       doubles;\n\
\n\
ClassA() : number(1), text("A") {\n\
};\n\
public:\n\
int method(String text, int number) {\n\
if (number==13) {\n\
return (int)System.currentTimeMillis();\n\
}else {\n\
{}\n\
}\n\
for( int i = 20; i < 100; i++) {\n\
    {\n\
        while(i%13>5)\n\
            method( text + " ", number++);\n\
    }\n\
}\n\
\n\
switch(number) {\n\
case 1:\n\
    do { out( (2+3)*this->number--); } while(this->number > 6);\n\
    return 10;\n\
case 2:\n\
    try {\n\
        toString();\n\
    }\n\
    catch ( IllegalStateException illegalStateException ) {\n\
        illegalStateException.printStackTrace();\n\
    }\n\
default:\n\
   return number > 100 ? -1 : -2;\n\
}\n\
}\n\
};\n\


# Should not be translated
SAMPLE_Spaces_c=struct ClassA {\n\
int    number;\n\
String text;\n\
};\n\
static float[] floats;\n\
double[]       doubles;\n\
\n\
doubles = {3.67,40,2e-30};\n\
\n\
int method(String text, int number) {\n\
if (number==13) {\n\
return (int)System.currentTimeMillis();\n\
}else {\n\
{}\n\
}\n\
for( int i = 20; i < 100; i++) {\n\
    {\n\
        while(i%13>5)\n\
            method( text + " ", number++);\n\
        toString("next");\n\
    }\n\
}\n\
\n\
switch(number) {\n\
case 1:\n\
    do { out( (2+3)*number--); } while(number > 6);\n\
    return 10;\n\
case 2:\n\
{\n\
    toString();\n\
}\n\
default:\n\
   return number > 100 ? -1 : -2;\n\
}\n\
}\n\


# Should not be translated
SAMPLE_TabsIndents_cpp=#include <Map>\n\
/*\n\
 */\n\
namespace A{\n\
class ClassA : InterfaceA, InterfaceB, InterfaceC {\n\
public:\n\
int number;\n\
enum inner {\n\
    PLUS, MINUS\n\
};\n\
private:\n\
char** cc;\n\
public:\n\
ClassA():cc({ "A", "B", "C", "D"}), number(2){\n\
}\n\
int method(char* text, int number) {\n\
if ( text == NULL ) {\n\
    text = "a";\n\
#ifdef C\n\
#define C1\n\
#ifdef F\n\
#define F2\n\
#endif\n\
#else\n\
#define C2\n\
#endif\n\
label:\n\
switch(number) {\n\
case 1:\n\
    return method("text", 22);\n\
case 2:\n\
    return 20;\n\
default:\n\
    return -1;\n\
}\n\
}\n\
else if (text[0] == 0) {\n\
    text = "empty";\n\
}\n\
else {\n\
    number++;\n\
}\n\
}\n\
};\n\
}\n\


# Should not be translated
SAMPLE_TabsIndents_c=#include <Map>\n\
/*\n\
 */\n\
struct ClassA\n\
{\n\
    int number;\n\
    static char** cc;\n\
};\n\
ClassA::cc = { "A", "B", "C", "D" };\n\
\n\
int method(char* text, int number)\n\
{\n\
    if ( text == NULL ) {\n\
        text = "a";\n\
#ifdef C\n\
#define C1\n\
#ifdef F\n\
#define F2\n\
#endif\n\
#else\n\
#define C2\n\
#endif\n\
    label:\n\
    switch(number) {\n\
        case 1:\n\
            return method("text", 22);\n\
        case 2:\n\
            return 20;\n\
        default:\n\
            return -1;\n\
    }\n\
    }\n\
    else if (text[0] == 0) {\n\
        text = "empty";\n\
    }\n\
    else {\n\
        number++;\n\
    }\n\
}\n\


# Should not be translated
SAMPLE_BlankLines_cpp=#include <List>\n\
#include <Map>\n\
\n\
class ClassA {\n\
public:\n\
int i;\n\
public:\n\
int j;\n\
public:\n\
ClassA() {\n\
};\n\
public:\n\
void methodA() {\n\
}\n\
void methodB() {\n\
}\n\
class innerClass {\n\
};\n\
class innerInterface {\n\
};\n\
};\n\


# Should not be translated
SAMPLE_BlankLines_c=#include <List>\n\
#include <Map>\n\
struct ClassA {\n\
int i;\n\
int j;\n\
};\n\
void methodA() {\n\
}\n\
void methodB() {\n\
}\n\
extern "C"{\n\
struct ClassA1 {\n\
int i;\n\
int j;\n\
};\n\
void methodA1() {\n\
}\n\
void methodB1() {\n\
}\n\
}\n\


